// Code generated by gen_atomic_float.py.  DO NOT EDIT.

package nhist

import (
	"math"
	"sync/atomic"
)

type Float32 atomic.Uint32

func (f *Float32) Load() float32 {
	return math.Float32frombits((*atomic.Uint32)(f).Load())
}

func (f *Float32) Store(v float32) {
	(*atomic.Uint32)(f).Store(math.Float32bits(v))
}

func (f *Float32) Swap(v float32) float32 {
	return math.Float32frombits((*atomic.Uint32)(f).Swap(math.Float32bits(v)))
}

func (f *Float32) CompareAndSwap(u, v float32) bool {
	return (*atomic.Uint32)(f).CompareAndSwap(math.Float32bits(u), math.Float32bits(v))
}

func (f *Float32) Add(v float32) (sum float32) {
	for {
		bits := (*atomic.Uint32)(f).Load()
		sum = math.Float32frombits(bits) + v
		if (*atomic.Uint32)(f).CompareAndSwap(bits, math.Float32bits(sum)) {
			return
		}
	}
}

func (f *Float32) Update(fn func(float32) float32) (new float32) {
	for {
		bits := (*atomic.Uint32)(f).Load()
		new = fn(math.Float32frombits(bits))
		if (*atomic.Uint32)(f).CompareAndSwap(bits, math.Float32bits(new)) {
			return
		}
	}
}

type Float64 atomic.Uint64

func (f *Float64) Load() float64 {
	return math.Float64frombits((*atomic.Uint64)(f).Load())
}

func (f *Float64) Store(v float64) {
	(*atomic.Uint64)(f).Store(math.Float64bits(v))
}

func (f *Float64) Swap(v float64) float64 {
	return math.Float64frombits((*atomic.Uint64)(f).Swap(math.Float64bits(v)))
}

func (f *Float64) CompareAndSwap(u, v float64) bool {
	return (*atomic.Uint64)(f).CompareAndSwap(math.Float64bits(u), math.Float64bits(v))
}

func (f *Float64) Add(v float64) (sum float64) {
	for {
		bits := (*atomic.Uint64)(f).Load()
		sum = math.Float64frombits(bits) + v
		if (*atomic.Uint64)(f).CompareAndSwap(bits, math.Float64bits(sum)) {
			return
		}
	}
}

func (f *Float64) Update(fn func(float64) float64) (new float64) {
	for {
		bits := (*atomic.Uint64)(f).Load()
		new = fn(math.Float64frombits(bits))
		if (*atomic.Uint64)(f).CompareAndSwap(bits, math.Float64bits(new)) {
			return
		}
	}
}
